from typing import Set, List, Optional, Dict, Tuple
from math import inf, isinf, copysign, sqrt, pow
from heapq import heapify, heappush, heappop
import networkx as nx
import re

Constraints = Dict[Tuple[int, str, int], float]


def generate_hamming_neighbours(state, k, current_dst, index, current_prefix):
    if current_dst > k:
        return []

    if index == len(state):
        return [current_prefix]

    # Rekurzivne vyrobim k-1 susedov pre aktualny prefix s flipnutou povodnou dalsou hodnotou
    next_flipped_prefix = current_prefix.copy()
    next_flipped_prefix.append(1 - state[index])
    flipped_neighbours = generate_hamming_neighbours(state, k, current_dst + 1, index + 1, next_flipped_prefix)

    # Rekurzivne vyrobim k susedov pre aktualny prefix s ponechanou povodnou dalsou hodnotou
    next_non_flipped_prefix = current_prefix.copy()
    next_non_flipped_prefix.append(state[index])
    non_flipped_neighbours = generate_hamming_neighbours(state, k, current_dst, index + 1, next_non_flipped_prefix)

    return flipped_neighbours + non_flipped_neighbours


def signed_distance(state, constraints: Constraints, manhattan: bool = True) -> float:
    """ Pokial su vsetky dimenzie vovnutri domain of validity, zaujima nas kajblizsia hranica.
    Pokial je niekolko dimenzii mimo DoV, zaujima nas ich sucet.

    Funguje aj v pripade, ze mame dve (zmyslupnle) podmienky na jedno premennu, pretoze:
    Ak su obidve kladne, zaujima nas len minimum (na dalsie sa nedostane z principu funkcie).
    Ak je jedna zaporna a druha nezaporna, dostane sa len na zapornu, kladna sa nepopne.
    Obe zaporne nemozu byt, to nie je zmysluplna podmienka."""

    distances = []
    heapify(distances)

    for (var, cmp, val), weight in constraints.items():
        if cmp == '<':
            heappush(distances, (val - state[var]) * weight)
        elif cmp == '>':
            heappush(distances, (state[var] - val) * weight)
        else:  # equality
            heappush(distances, - abs(state[var] - val) * weight)

    if manhattan:
        return manhattan_distance(distances)
    return euclidean_distance(distances)


def manhattan_distance(distances_heap: List[int]) -> float:
    result = 0
    if distances_heap[0] > 0:
        return distances_heap[0]

    while distances_heap:
        dst = heappop(distances_heap)
        if dst >= 0:
            break
        result += dst

    return result


def euclidean_distance(distances_heap: List[int]) -> float:
    dst = heappop(distances_heap)
    if dst >= 0:
        return dst

    result = pow(dst, 2)
    while distances_heap:
        dst = heappop(distances_heap)
        if dst >= 0:
            break
        result += pow(dst, 2)

    return -sqrt(result)


def parse_graphviz(text):
    states = []
    transitions = {}

    node_lines = re.findall(r'(\d+) \[.*\];', text)
    for node_line in node_lines:
        states.append(tuple(int(var) for var in node_line))

    edge_lines = re.findall(r'(\d+) -> (\d+);', text)
    for source, target in edge_lines:
        transitions.setdefault(states.index(tuple(int(var) for var in source)), []) \
            .append(states.index(tuple(int(var) for var in target)))

    return STG(states, transitions)


graph_text = """
/* Graphviz file generated by GINsim - March 27, 2024 at 6:45:43 PM CET */

digraph G {
	000 [label="000", shape="box"];
	100 [label="100", shape="box"];
	110 [label="110", shape="box"];
	010 [label="010", shape="box"];
	001 [label="001", shape="box"];
	101 [label="101", shape="box"];
	011 [label="011", shape="box"];
	111 [label="111", shape="box"];
	000 -> 001;
	000 -> 010;
	100 -> 101;
	100 -> 110;
	110 -> 010;
	010 -> 011;
	010 -> 110;
	001 -> 011;
	101 -> 111;
	011 -> 111;
	111 -> 110;
	111 -> 011;
}
"""

from itertools import combinations, product


def manhattan_neighbors(point, distance):
    """
    Generates all points that are exactly `distance` away from `point`
    using Manhattan (L1) norm. This is a generator that yields one point at a time.

    :param point: Tuple (x0, x1, ..., xn) representing the original point.
    :param distance: Integer, the exact Manhattan distance to generate neighbors.
    :yield: A point that is exactly `distance` away.
    """
    if distance == 0:
        yield point  # The point itself is at distance 0
        return

    n = len(point)

    # Generate combinations of indices to modify, and product of signs for each axis
    for indices in combinations(range(n), distance):  # Choose `distance` axes to change
        for signs in product([-1, 1], repeat=distance):  # Assign +1 or -1 to each change
            neighbor = list(point)
            for idx, sign in zip(indices, signs):
                neighbor[idx] += sign
            yield tuple(neighbor)


def signed_distance(point, S_definitions):
    """
    Computes the signed Manhattan distance from `point` to the closest boundary of S.

    - Returns a **positive** value if inside S (distance to closest boundary).
    - Returns a **negative** value if outside S (distance to closest point in S).

    Iterates over expanding Manhattan distances.
    """
    start_inside = in_S(point, S_definitions)

    distance = 0
    while True:
        # Use the generator to get neighbors at the current distance
        for neighbor in manhattan_neighbors(point, distance):
            if in_S(neighbor, S_definitions) != start_inside:
                return distance if start_inside else -distance
        distance += 1


def is_inside(point, region):
    """
    Checks if a point satisfies all constraints in a conjunctive region.

    :param point: Tuple (x0, x1, ..., xn) representing the point in n-dimensional space.
    :param region: List of constraints in the form [(i, op, value), ...] where:
                   - i is the index of the coordinate
                   - op is ">=" or "<="
                   - value is the threshold
    :return: True if the point satisfies ALL constraints in the region.
    """
    for i, op, value in region:
        if op == ">=" and point[i] < value:
            return False
        elif op == "<=" and point[i] > value:
            return False
    return True


def in_S(point, S_definitions):
    """Returns True if the point satisfies at least one conjunctive region."""
    return any(is_inside(point, region) for region in S_definitions)